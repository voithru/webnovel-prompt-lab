import React, { useState, useEffect } from 'react'
import { useLocation, useNavigate } from 'react-router-dom'
import { useDesignSystemContext } from '../components/common/DesignSystemProvider'
import { AutoStyledButton, AutoStyledInput, AutoStyledCard } from '../components/common/AutoStyledComponent'
import Button from '../components/common/Button'
import PromptBubble from '../components/common/PromptBubble'
import AppLayout from '../components/layout/AppLayout'
import BottomActionBar from '../components/common/BottomActionBar'
import styles from '../styles/pages/PromptReviewPage.module.css'

const FinalSelectionPage = () => {
  const { designTokens } = useDesignSystemContext()
  const location = useLocation()
  const navigate = useNavigate()
  const taskData = location.state || {}
  
  // 상태 관리
  const [activeTab, setActiveTab] = useState('liked') // 'liked' or 'all'
  const [selectedPrompt, setSelectedPrompt] = useState(null)
  const [prompts, setPrompts] = useState([])
  const [originalText, setOriginalText] = useState('')
  const [baselineTranslation, setBaselineTranslation] = useState('')
  const [commentText, setCommentText] = useState('')
  const [isCommentEditing, setIsCommentEditing] = useState(false)
  const [savedComments, setSavedComments] = useState({})
  const [translationView, setTranslationView] = useState('original') // 'original' or 'baseline'
  const [bestPromptId, setBestPromptId] = useState(null)

  // 과제 정보
  const {
    title = '미필적 고의에 의한 연애사',
    episode = '01',
    languagePair = '한국어 → 일본어',
    projectSeason = '과제 시즌 1',
    taskId,
    stepOrder
  } = taskData

  // 컴포넌트 마운트 시 데이터 로드
  useEffect(() => {
    if (location.state) {
      const { 
        prompts: savedPrompts, 
        originalText: savedOriginalText, 
        baselineTranslation: savedBaselineTranslation,
        savedComments: existingComments 
      } = location.state
      
      setPrompts(savedPrompts || [])
      setOriginalText(savedOriginalText || '')
      setBaselineTranslation(savedBaselineTranslation || '')
      setSavedComments(existingComments || {})
    } else if (taskId) {
      // location.state가 없으면 로컬 스토리지에서 복원 시도
      const savedData = localStorage.getItem(`promptReview_${taskId}`)
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData)
          console.log('🔄 로컬 스토리지에서 프롬프트 검토 데이터 복원 중...')
          
          if (parsedData.prompts) setPrompts(parsedData.prompts)
          if (parsedData.originalText) setOriginalText(parsedData.originalText)
          if (parsedData.baselineTranslation) setBaselineTranslation(parsedData.baselineTranslation)
          if (parsedData.savedComments) setSavedComments(parsedData.savedComments)
          
          console.log('✅ 로컬 스토리지에서 데이터 복원 완료')
        } catch (error) {
          console.error('로컬 스토리지 데이터 파싱 실패:', error)
        }
      }
    }
  }, [location.state, taskId])

  // 좋아요 프롬프트만 필터링
  const likedPrompts = prompts.filter(prompt => prompt.isLiked === true)
  const allPrompts = prompts

  // 제출 대상 항목은 좋아요 프롬프트만 표시
  const displayPrompts = likedPrompts

  // Best 프롬프트 선택 처리
  const handleBestPromptSelect = (promptId) => {
    setBestPromptId(promptId)
    console.log('🏆 Best 프롬프트 선택:', promptId)
  }

  // 프롬프트 선택 처리
  const handlePromptSelect = (prompt) => {
    setSelectedPrompt(prompt)
    
    if (prompt.isLiked === true) {
      // 좋아요 프롬프트인 경우
      if (savedComments[prompt.id]) {
        // 이미 저장된 코멘트가 있으면 수정 모드가 아닌 상태로 설정
        setCommentText(savedComments[prompt.id])
        setIsCommentEditing(false)
      } else {
        // 저장된 코멘트가 없으면 새로운 코멘트 작성 모드로 설정
        setCommentText('')
        setIsCommentEditing(true) // 처음 작성할 때는 수정 모드로 시작
      }
    } else {
      // 싫어요 프롬프트인 경우
      setCommentText('')
      setIsCommentEditing(false)
    }
  }

  // 좋아요/싫어요 상태 변경 처리
  const handleLikeDislikeChange = (promptId, newIsLiked) => {
    const updatedPrompts = prompts.map(prompt => {
      if (prompt.id === promptId) {
        const updatedPrompt = { ...prompt, isLiked: newIsLiked }
        
        // 좋아요로 변경 시 좋아요 프롬프트 탭으로 이동
        if (newIsLiked && activeTab === 'all') {
          setActiveTab('liked')
        }
        
        // 싫어요로 변경 시 코멘트 삭제 확인
        if (!newIsLiked && savedComments[promptId]) {
          if (window.confirm('이미 작성한 코멘트가 있습니다. 싫어요로 변경하면 코멘트가 삭제됩니다. 계속하시겠습니까?')) {
            const newSavedComments = { ...savedComments }
            delete newSavedComments[promptId]
            setSavedComments(newSavedComments)
          } else {
            return prompt // 변경 취소
          }
        }
        
        return updatedPrompt
      }
      return prompt
    })
    
    setPrompts(updatedPrompts)
  }

  // 코멘트 저장 처리
  const handleCommentSave = () => {
    if (selectedPrompt && commentText.trim().length >= 20) {
      const newSavedComments = {
        ...savedComments,
        [selectedPrompt.id]: commentText.trim()
      }
      
      // 상태 업데이트
      setSavedComments(newSavedComments)
      setIsCommentEditing(false)
      
      // 로컬 스토리지에 즉시 저장 (코멘트 데이터 유지)
      const saveData = {
        prompts,
        originalText,
        baselineTranslation,
        savedComments: newSavedComments, // 업데이트된 코멘트
        taskId,
        stepOrder
      }
      localStorage.setItem(`promptReview_${taskId}`, JSON.stringify(saveData))
      console.log('💾 코멘트 저장 완료 및 로컬 스토리지 업데이트:', selectedPrompt.id)
    }
  }

  // 코멘트 수정 모드 활성화
  const handleCommentEdit = () => {
    setIsCommentEditing(true)
    // 현재 저장된 코멘트를 텍스트 박스에 표시
    if (selectedPrompt && savedComments[selectedPrompt.id]) {
      setCommentText(savedComments[selectedPrompt.id])
    }
  }

  // 코멘트 수정 취소
  const handleCommentCancel = () => {
    if (isCommentEditing) {
      if (savedComments[selectedPrompt?.id]) {
        // 수정 모드일 때는 저장된 코멘트로 되돌리기
        setCommentText(savedComments[selectedPrompt.id])
        setIsCommentEditing(false)
      } else {
        // 처음 작성 모드일 때는 텍스트 초기화하고 수정 모드 유지
        setCommentText('')
        setIsCommentEditing(true)
      }
    } else {
      // 일반 모드일 때는 코멘트 텍스트 초기화
      setCommentText('')
    }
  }

  // 임시 저장 처리
  const handleTemporarySave = () => {
    // 현재 상태를 로컬 스토리지에 저장
    const saveData = {
      prompts,
      originalText,
      baselineTranslation,
      savedComments,
      taskId,
      stepOrder
    }
    localStorage.setItem(`promptReview_${taskId}`, JSON.stringify(saveData))
    
    // 진행 상태를 '진행중'으로 업데이트
    if (prompts.length > 0) {
      localStorage.setItem(`taskProgress_${taskId}`, '진행중')
    }
    
    alert('임시 저장이 완료되었습니다.')
    console.log('💾 임시 저장 완료')
  }

  // 이전 페이지로 이동
  const handlePrevious = () => {
    // 현재 상태를 업데이트해서 로컬 스토리지에 저장 (코멘트, 좋아요/싫어요 상태 반영)
    const updatedData = {
      prompts: prompts.map(prompt => ({
        ...prompt,
        // 프롬프트 검토 페이지에서 변경된 상태 반영
        isLiked: prompt.isLiked,
        comment: savedComments[prompt.id] || null
      })),
      originalText,
      baselineTranslation,
      savedComments, // 코멘트 데이터 포함
      taskId,
      stepOrder
    }
    
    localStorage.setItem(`promptInput_${taskId}`, JSON.stringify(updatedData))
    
    // 진행 상태를 '진행중'으로 업데이트
    if (prompts.length > 0) {
      localStorage.setItem(`taskProgress_${taskId}`, '진행중')
    }
    
    console.log('💾 프롬프트 검토 페이지 상태 업데이트 후 저장 완료 (코멘트 포함)')
    
    // 이전 페이지로 이동
    navigate(-1)
  }

  // 다음 페이지로 이동 (최종안 선택 및 평가 작성)
  const handleNext = () => {
    // 모든 좋아요 프롬프트에 코멘트가 작성되었는지 확인
    const hasAllComments = likedPrompts.every(prompt => 
      savedComments[prompt.id] && savedComments[prompt.id].trim().length >= 20
    )
    
    if (!hasAllComments) {
      alert('모든 좋아요 프롬프트에 대해 코멘트를 작성해주세요.')
      return
    }
    
    // 현재 상태를 로컬 스토리지에 저장 (코멘트 포함)
    const saveData = {
      prompts,
      originalText,
      baselineTranslation,
      savedComments, // 코멘트 데이터 포함
      taskId,
      stepOrder
    }
    localStorage.setItem(`promptReview_${taskId}`, JSON.stringify(saveData))
    console.log('💾 다음 페이지 이동 전 코멘트 데이터 저장 완료')
    
    // 다음 페이지로 이동 (데이터와 함께)
    navigate('/final-selection-page', {
      state: {
        prompts,
        originalText,
        baselineTranslation,
        savedComments, // 코멘트 데이터 포함
        taskId,
        stepOrder,
        ...taskData
      }
    })
  }

  // 코멘트 작성 완료 여부 확인
  const getCommentStatus = (promptId) => {
    const comment = savedComments[promptId]
    if (comment && comment.trim().length >= 20) {
      return { status: 'completed', text: '평가 작성 완료' }
    }
    return { status: 'incomplete', text: '평가 작성 미완료' }
  }

  return (
    <AppLayout currentPage="프롬프트 검토" variant="withoutHeader">
      <div className={styles.container}>

        {/* 메인 콘텐츠 영역 */}
        <div className={styles.mainContent}>
          {/* 왼쪽 영역 - 프롬프트 목록 */}
          <div className={styles.leftSection}>
            <div style={{ marginBottom: '24px' }}>
              <h2 className={styles.sectionTitle}>
                제출 대상 항목
              </h2>
            </div>

            {/* 프롬프트 목록 */}
            <div className={styles.promptList}>
              {displayPrompts.map((prompt) => {
                                  const commentStatus = getCommentStatus(prompt.id)
                  return (
                    <div
                      key={prompt.id}
                      style={{
                        marginBottom: '16px',
                        position: 'relative'
                      }}
                    >
                      {/* 라디오 버튼 - 왼쪽 상단 */}
                      <div style={{
                        position: 'absolute',
                        top: '8px',
                        left: '8px',
                        zIndex: 10
                      }}>
                        <input
                          type="radio"
                          id={`best-${prompt.id}`}
                          name="bestPrompt"
                          value={prompt.id}
                          checked={bestPromptId === prompt.id}
                          onChange={(e) => handleBestPromptSelect(e.target.value)}
                          onClick={(e) => e.stopPropagation()}
                          style={{
                            width: '16px',
                            height: '16px',
                            cursor: 'pointer',
                            accentColor: '#3b82f6'
                          }}
                        />
                        <label
                          htmlFor={`best-${prompt.id}`}
                          style={{
                            marginLeft: '6px',
                            fontSize: '11px',
                            color: '#6b7280',
                            cursor: 'pointer',
                            userSelect: 'none',
                            fontWeight: '500'
                          }}
                          onClick={(e) => e.stopPropagation()}
                        >
                          Best
                        </label>
                      </div>

                      {/* 기존 프롬프트 컨테이너 */}
                      <div
                        onClick={() => handlePromptSelect(prompt)}
                        className={`${styles.promptItem} ${selectedPrompt?.id === prompt.id ? styles.selected : ''}`}
                        style={{
                          marginTop: '8px'
                        }}
                      >
                        {/* 프롬프트 버전과 상태 */}
                        <div className={styles.promptHeader}>
                          {/* 버전 라벨 */}
                          <div style={{
                            backgroundColor: '#3b82f6',
                            color: 'white',
                            padding: '4px 8px',
                            borderRadius: '12px',
                            fontSize: '12px',
                            fontWeight: '500'
                          }}>
                            {prompt.version || `V${prompt.id}`}
                          </div>
                          
                          {/* 평가 상태 */}
                          <div className={`${styles.commentStatus} ${commentStatus.status === 'completed' ? styles.completed : styles.incomplete}`}>
                            {commentStatus.text}
                          </div>
                        </div>
                      </div>

                      {/* 버전 라벨 */}
                      <div style={{
                        backgroundColor: '#3b82f6',
                        color: 'white',
                        padding: '4px 8px',
                        borderRadius: '12px',
                        fontSize: '12px',
                        fontWeight: '500'
                      }}>
                        {prompt.version || `V${prompt.id}`}
                      </div>
                      
                      {/* 평가 상태 */}
                      <div className={`${styles.commentStatus} ${commentStatus.status === 'completed' ? styles.completed : styles.incomplete}`}>
                        {commentStatus.text}
                      </div>
                    </div>

                    {/* 프롬프트 내용 */}
                    <div className={styles.promptText}>
                      {prompt.text}
                    </div>

                    {/* 좋아요/싫어요 버튼 - PromptBubble에서 그대로 가져온 컴포넌트 */}
                    <div style={{
                      display: 'flex',
                      backgroundColor: designTokens.colors.background.secondary || '#f3f4f6',
                      borderRadius: designTokens.borders.radius.md || '8px',
                      border: `1px solid ${designTokens.colors.border.light}`,
                      overflow: 'hidden',
                      transition: 'all 0.2s ease',
                      position: 'relative',
                      zIndex: 10,
                      width: 'fit-content'
                    }}>
                      {/* 좋아요 버튼 */}
                      <button
                        onClick={(e) => {
                          e.stopPropagation()
                          handleLikeDislikeChange(prompt.id, true)
                        }}
                        style={{
                          padding: '8px 12px',
                          backgroundColor: prompt.isLiked === true ? designTokens.colors.success || '#22c55e' : 'transparent',
                          border: 'none',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'all 0.2s ease',
                          color: prompt.isLiked === true ? 'white' : designTokens.colors.text.muted || '#6b7280',
                          borderRadius: '0',
                          outline: 'none',
                          flex: '0 0 auto'
                        }}
                        onMouseEnter={(e) => {
                          // 싫어요가 선택된 상태가 아닐 때만 호버 효과 적용
                          if (prompt.isLiked !== true && prompt.isLiked !== false) {
                            e.target.style.backgroundColor = 'rgba(34, 197, 94, 0.2)'
                            e.target.style.color = designTokens.colors.success || '#22c55e'
                          }
                        }}
                        onMouseLeave={(e) => {
                          // 싫어요가 선택된 상태가 아닐 때만 원래 상태로 복원
                          if (prompt.isLiked !== true && prompt.isLiked !== false) {
                            e.target.style.backgroundColor = 'transparent'
                            e.target.style.color = designTokens.colors.text.muted || '#6b7280'
                          }
                        }}
                        onMouseDown={(e) => {
                          e.target.style.transform = 'scale(0.95)'
                        }}
                        onMouseUp={(e) => {
                          e.target.style.transform = 'scale(1)'
                        }}
                        onFocus={(e) => {
                          e.target.style.outline = `2px solid ${designTokens.colors.success || '#22c55e'}`
                          e.target.style.outlineOffset = '2px'
                        }}
                        onBlur={(e) => {
                          e.target.style.outline = 'none'
                        }}
                      >
                        <svg 
                          width="16" 
                          height="16" 
                          viewBox="0 0 24 24" 
                          fill={prompt.isLiked === true ? 'white' : 'none'} 
                          stroke={prompt.isLiked === true ? 'white' : 'currentColor'} 
                          strokeWidth="2"
                        >
                          <path d="M14 9V5a3 3 0 0 0-6 0v4H4a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-2z" />
                          <path d="M9 12l2 2 4-4" />
                        </svg>
                      </button>

                      {/* 구분선 */}
                      <div style={{
                        width: '1px',
                        backgroundColor: designTokens.colors.border.light,
                        margin: '4px 0'
                      }} />

                      {/* 싫어요 버튼 */}
                      <button
                        onClick={(e) => {
                          e.stopPropagation()
                          handleLikeDislikeChange(prompt.id, false)
                        }}
                        style={{
                          padding: '8px 12px',
                          backgroundColor: prompt.isLiked === false ? designTokens.colors.error || '#ef4444' : 'transparent',
                          border: 'none',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'all 0.2s ease',
                          color: prompt.isLiked === false ? 'white' : designTokens.colors.text.muted || '#6b7280',
                          borderRadius: '0',
                          outline: 'none',
                          flex: '0 0 auto'
                        }}
                        onMouseEnter={(e) => {
                          // 좋아요가 선택된 상태가 아닐 때만 호버 효과 적용
                          if (prompt.isLiked !== false && prompt.isLiked !== true) {
                            e.target.style.backgroundColor = 'rgba(239, 68, 68, 0.2)'
                            e.target.style.color = designTokens.colors.error || '#ef4444'
                          }
                        }}
                        onMouseLeave={(e) => {
                          // 좋아요가 선택된 상태가 아닐 때만 원래 상태로 복원
                          if (prompt.isLiked !== false && prompt.isLiked !== true) {
                            e.target.style.backgroundColor = 'transparent'
                            e.target.style.color = designTokens.colors.text.muted || '#6b7280'
                          }
                        }}
                        onMouseDown={(e) => {
                          e.target.style.transform = 'scale(0.95)'
                        }}
                        onMouseUp={(e) => {
                          e.target.style.transform = 'scale(1)'
                        }}
                        onFocus={(e) => {
                          e.target.style.outline = `2px solid ${designTokens.colors.error || '#ef4444'}`
                          e.target.style.outlineOffset = '2px'
                        }}
                        onBlur={(e) => {
                          e.target.style.outline = 'none'
                        }}
                      >
                        <svg 
                          width="16" 
                          height="16" 
                          viewBox="0 0 24 24" 
                          fill={prompt.isLiked === false ? 'white' : 'none'} 
                          stroke={prompt.isLiked === false ? 'white' : 'currentColor'} 
                          strokeWidth="2"
                        >
                          <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17" />
                        </svg>
                      </button>
                    </div>

                    {/* 타임스탬프 */}
                    <div className={styles.timestamp}>
                      {(() => {
                        try {
                          // timestamp가 Date 객체인지 문자열인지 확인
                          const dateObj = prompt.timestamp instanceof Date ? prompt.timestamp : new Date(prompt.timestamp)
                          if (isNaN(dateObj.getTime())) {
                            // 유효하지 않은 날짜인 경우 기본값 반환
                            return '2025. 8.8 16:20'
                          }
                          return `${dateObj.toLocaleDateString('ko-KR', {
                            month: 'long',
                            day: 'numeric'
                          })} ${dateObj.toLocaleTimeString('ko-KR', {
                            hour: '2-digit',
                            minute: '2-digit'
                          })}`
                        } catch (error) {
                          console.warn('타임스탬프 파싱 오류:', error)
                          return '2025. 8.8 16:20'
                        }
                      })()}
                    </div>
                  </div> {/* 프롬프트 컨테이너 닫기 */}
                </div> {/* 겉에 컨테이너 닫기 */}
                )
              })}
            </div>
          </div>

          {/* 오른쪽 영역 - 번역문 및 코멘트 */}
          <div className={styles.rightSection}>
            {/* 과제 정보 라벨과 브레드크럼 */}
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '16px',
              padding: '0 16px'
            }}>
              {/* 과제 정보 라벨들 */}
              <div style={{
                display: 'flex',
                gap: '12px',
                flexWrap: 'wrap'
              }}>
                <div style={{
                  padding: '8px 16px',
                  backgroundColor: 'var(--primary)',
                  color: 'white',
                  borderRadius: '9999px',
                  fontSize: '14px',
                  fontWeight: '500'
                }}>
                  {projectSeason}
                </div>
                <div style={{
                  padding: '8px 16px',
                  backgroundColor: designTokens.colors.background.secondary,
                  color: designTokens.colors.text.muted,
                  borderRadius: designTokens.borders.radius.full,
                  fontSize: designTokens.typography.fontSize.sm,
                  border: `1px solid ${designTokens.colors.border.light}`
                }}>
                  {title} - EP {episode}
                </div>
                <div style={{
                  padding: '8px 16px',
                  backgroundColor: designTokens.colors.background.secondary,
                  color: designTokens.colors.text.muted,
                  borderRadius: designTokens.borders.radius.full,
                  fontSize: designTokens.typography.fontSize.sm,
                  border: `1px solid ${designTokens.colors.border.light}`
                }}>
                  {stepOrder ? `Step ${stepOrder}` : 'Step 1'}
                </div>
                <div style={{
                  padding: '8px 16px',
                  backgroundColor: designTokens.colors.background.secondary,
                  color: designTokens.colors.text.muted,
                  borderRadius: designTokens.borders.radius.full,
                  fontSize: designTokens.typography.fontSize.sm,
                  border: `1px solid ${designTokens.colors.border.light}`
                }}>
                  {languagePair}
                </div>
              </div>
              
              {/* 브레드크럼 - 프롬프트 입력 페이지와 동일한 스타일 */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px',
                fontSize: '14px',
                color: '#64748b'
              }}>
                <span style={{ color: '#64748b' }}>나의 과제</span>
                <span style={{ color: '#cbd5e1' }}>/</span>
                <span style={{ color: '#64748b' }}>프롬프트 입력</span>
                <span style={{ color: '#cbd5e1' }}>/</span>
                <span style={{ color: '#1e293b', fontWeight: '600' }}>프롬프트 검토</span>
              </div>
            </div>
            
            {/* 첫 번째 콘텐츠 영역: 기본 번역문, 원문, 프롬프트 결과 번역문을 가로로 배치 */}
            <div style={{ 
              display: 'flex', 
              gap: '16px',
              minWidth: 0, // flexbox에서 스크롤이 제대로 작동하도록
              padding: '16px', // 첫 번째 영역 패딩
              backgroundColor: 'rgba(0, 0, 0, 0.02)', // 구분을 위한 배경색
              borderRadius: '12px', // 둥근 테두리
              border: '1px solid rgba(0, 0, 0, 0.1)', // 테두리
              marginBottom: '24px', // 하단 여백 추가
              height: '600px' // 적절한 높이로 설정하여 하단 피드백 영역 확보
            }}>
              {/* 기본 번역문과 원문을 토글 버튼 그룹으로 */}
              <div style={{ 
                flex: 1, 
                display: 'flex', 
                flexDirection: 'column',
                gap: '16px',
                minWidth: 0, // flexbox에서 스크롤이 제대로 작동하도록
                height: '100%' // 높이를 100%로 설정하여 부모 컨테이너에 맞춤
              }}>
                {/* 토글 버튼 그룹 - 프롬프트 입력 페이지와 동일한 스타일 */}
                <div style={{
                  display: 'flex',
                  backgroundColor: designTokens.colors.background.secondary,
                  borderRadius: designTokens.borders.radius.md,
                  padding: '4px',
                  border: `1px solid ${designTokens.colors.border.light}`,
                  flexShrink: 0 // 축소되지 않도록 고정
                }}>
              <button
                onClick={() => setTranslationView('original')}
                style={{
                  flex: 1,
                  padding: '12px 24px',
                  backgroundColor: translationView === 'original' 
                    ? designTokens.colors.background.primary 
                    : 'transparent',
                  color: translationView === 'original' 
                    ? designTokens.colors.text.primary 
                    : designTokens.colors.text.muted,
                  border: 'none',
                  borderRadius: designTokens.borders.radius.sm,
                  fontSize: designTokens.typography.fontSize.sm,
                  fontWeight: designTokens.typography.fontWeight.medium,
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                원문
              </button>
              <button
                onClick={() => setTranslationView('baseline')}
                style={{
                  flex: 1,
                  padding: '12px 24px',
                  backgroundColor: translationView === 'baseline' 
                    ? designTokens.colors.background.primary 
                    : 'transparent',
                  color: translationView === 'baseline' 
                    ? designTokens.colors.text.primary 
                    : designTokens.colors.text.muted,
                  border: 'none',
                  borderRadius: designTokens.borders.radius.sm,
                  fontSize: designTokens.typography.fontSize.sm,
                  fontWeight: designTokens.typography.fontWeight.medium,
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                기본 번역문
              </button>
            </div>

                {/* 토글에 따른 텍스트 영역 */}
                <div style={{ 
                  flex: 1,
                  padding: '16px',
                  backgroundColor: 'white',
                  border: '1px solid var(--border-light)',
                  borderRadius: '8px',
                  overflow: 'auto',
                  minHeight: 0 // flexbox에서 스크롤이 제대로 작동하도록
                }}>
                  {translationView === 'baseline' ? (
                    // 기본 번역문 표시
                    <div style={{
                      fontSize: '14px',
                      lineHeight: '1.6',
                      color: 'var(--text-muted)',
                      whiteSpace: 'pre-wrap',
                      wordWrap: 'break-word',
                      overflowWrap: 'break-word',
                      wordBreak: 'break-all'
                    }}>
                      {baselineTranslation || '기본 번역문이 여기에 표시됩니다.'}
                    </div>
                  ) : (
                    // 원문 표시
                    <div style={{
                      fontSize: '14px',
                      lineHeight: '1.6',
                      color: 'var(--text-muted)',
                      whiteSpace: 'pre-wrap',
                      wordWrap: 'break-word',
                      overflowWrap: 'break-word',
                      wordBreak: 'break-all'
                    }}>
                      {originalText || '원문이 여기에 표시됩니다.'}
                    </div>
                  )}
                </div>
              </div>

              {/* 중앙 패널: 프롬프트 결과 번역문 - 왼쪽과 동일한 너비 */}
              <div style={{ 
                flex: 1, // flex: 1로 변경하여 왼쪽과 동일한 너비
                display: 'flex', 
                flexDirection: 'column', 
                gap: '16px',
                minWidth: 0, // flexbox에서 스크롤이 제대로 작동하도록
                height: '100%' // 높이를 100%로 설정하여 부모 컨테이너에 맞춤
              }}>
                {/* 프롬프트 결과 번역문 헤더 - 프롬프트 입력 페이지와 동일한 스타일 */}
                <div style={{
                  display: 'flex',
                  backgroundColor: designTokens.colors.background.primary, // 선택된 상태로 표시
                  borderRadius: designTokens.borders.radius.md,
                  padding: '16px 24px', // 토글 버튼과 동일한 패딩
                  border: `1px solid ${designTokens.colors.border.light}`,
                  flexShrink: 0, // 축소되지 않도록 고정
                  alignItems: 'center',
                  justifyContent: 'center'
                }}>
                  <span style={{
                    fontSize: designTokens.typography.fontSize.sm,
                    fontWeight: designTokens.typography.fontWeight.medium,
                    color: designTokens.colors.text.primary // 선택된 상태의 텍스트 색상
                  }}>
                    프롬프트 결과 번역문
                  </span>
                </div>
                <div style={{ 
                  flex: 1,
                  padding: '16px',
                  backgroundColor: 'white',
                  border: '1px solid var(--border-light)',
                  borderRadius: '8px',
                  overflow: 'auto',
                  minHeight: 0 // flexbox에서 스크롤이 제대로 작동하도록
                }}>
                  <div style={{
                    fontSize: '14px',
                    lineHeight: '1.6',
                    color: 'var(--text-muted)',
                    whiteSpace: 'pre-wrap',
                    wordWrap: 'break-word',
                    overflowWrap: 'break-word',
                    wordBreak: 'break-all'
                  }}>
                    {selectedPrompt?.result || '프롬프트를 선택하면 번역 결과가 여기에 표시됩니다.'}
                  </div>
                </div>
              </div>
            </div>

            {/* 코멘트 작성 영역 */}
            <div className={styles.commentSection}>
              <h3 className={styles.translationSubtitle}>
                코멘트 작성
              </h3>
              
              {!selectedPrompt ? (
                // 1. 왼쪽의 프롬프트를 하나도 선택하지 않은 기본 상태
                <div className={styles.commentPlaceholder}>
                  <div className={styles.placeholderContent}>
                    <span>왼쪽의 프롬프트를 선택하여 입력을 활성화해 주세요.</span>
                    <div className={styles.helpIcon}>
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm0 14c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z"/>
                        <path d="M7 12h2v2H7zm1-10c-1.7 0-3 1.3-3 3h2c0-.6.4-1 1-1s1 .4 1 1c0 .7-.4 1.3-1 1.5V10H7V6.5c1.2-.3 2-1.4 2-2.5z"/>
                      </svg>
                    </div>
                  </div>
                </div>
              ) : (
                // 2. 좋아요 프롬프트를 선택했으나 텍스트 입력을 아직 않은 상태
                // 3. 싫어요 평가를 받은 프롬프트를 클릭한 상태  
                // 4. 좋아요 프롬프트를 입력하고 저장한 상태
                <div>
                  {/* 코멘트 텍스트 박스 */}
                  <div style={{
                    padding: '16px',
                    backgroundColor: 'white',
                    border: '1px solid var(--border-light)',
                    borderRadius: '8px',
                    height: '100px',
                    position: 'relative'
                  }}>
                    <textarea
                      className="text-input-common"
                      placeholder={
                        selectedPrompt.isLiked === false 
                          ? "싫어요 평가를 받은 결과물에 대해서는 평가를 작성할 수 없습니다."
                          : "코멘트를 입력해주세요..."
                      }
                      value={commentText}
                      onChange={(e) => setCommentText(e.target.value)}
                      disabled={selectedPrompt.isLiked === false}
                      style={{
                        width: '100%',
                        height: '100%',
                        fontSize: '14px',
                        padding: '0px', // 마진을 더 작게 조정
                        backgroundColor: 'white',
                        color: selectedPrompt.isLiked === false ? 'var(--text-muted)' : 'var(--text-primary)',
                        cursor: selectedPrompt.isLiked === false ? 'not-allowed' : 'text',
                        border: 'none',
                        outline: 'none',
                        resize: 'none',
                        fontFamily: 'inherit'
                      }}
                    />
                  </div>
                  
                  {/* 안내 문구 */}
                  <div style={{
                    fontSize: '12px',
                    color: 'rgba(0, 0, 0, 0.4)',
                    marginTop: '8px',
                    marginBottom: '16px',
                    textAlign: 'left'
                  }}>
                    * 좋아요 프롬프트는 20자 이상의 코멘트 입력이 필수입니다.
                  </div>
                  
                  {/* 코멘트 액션 버튼들 */}
                  <div className={styles.commentActions}>
                    {selectedPrompt.isLiked === false ? (
                      // 3. 싫어요 프롬프트 - 모든 버튼 비활성화
                      <>
                        <Button
                          variant="secondary"
                          size="small"
                          style="solid"
                          disabled
                        >
                          코멘트 수정
                        </Button>
                        <div className={styles.rightButtons}>
                          <Button
                            variant="secondary"
                            size="small"
                            style="solid"
                            disabled
                          >
                            취소
                          </Button>
                          <Button
                            variant="blue"
                            size="small"
                            style="solid"
                            disabled
                          >
                            저장
                          </Button>
                        </div>
                      </>
                    ) : (
                      // 2. 좋아요 프롬프트 - 항상 모든 버튼 표시, 상태에 따라 활성화/비활성화
                      <>
                        {/* 코멘트 수정 버튼 - 저장된 코멘트가 있고 수정 모드가 아닐 때만 활성화 */}
                        <Button
                          variant={savedComments[selectedPrompt.id] ? "blue" : "secondary"}
                          size="small"
                          style="solid"
                          onClick={savedComments[selectedPrompt.id] ? handleCommentEdit : undefined}
                          disabled={!savedComments[selectedPrompt.id] || isCommentEditing}
                        >
                          코멘트 수정
                        </Button>
                        
                        {/* 취소와 저장 버튼 - 수정 모드일 때만 활성화 */}
                        <div className={styles.rightButtons}>
                          <Button
                            variant="secondary"
                            size="small"
                            style="solid"
                            onClick={handleCommentCancel}
                            disabled={!isCommentEditing}
                          >
                            취소
                          </Button>
                          <Button
                            variant="blue"
                            size="small"
                            style="solid"
                            onClick={handleCommentSave}
                            disabled={!isCommentEditing || commentText.trim().length < 20}
                          >
                            저장
                          </Button>
                        </div>
                      </>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
        
        {/* 하단 고정 액션 버튼들 */}
        <BottomActionBar
          leftButtons={[
            { text: '이전', variant: 'secondary', size: 'md', onClick: handlePrevious },
            { text: '임시 저장', variant: 'secondary', size: 'md', onClick: handleTemporarySave }
          ]}
          rightButton={{
            text: '최종안 선택 및 평가 작성',
            variant: 'blue',
            size: 'medium',
            style: 'solid',
            onClick: handleNext,
            rightIcon: (
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M5 12h14M12 5l7 7-7 7" />
              </svg>
            )
          }}
        />
      </div>
    </AppLayout>
  )
}

export default FinalSelectionPage
